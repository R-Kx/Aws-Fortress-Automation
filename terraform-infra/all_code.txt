resource "aws_lb" "flask_alb" {
    name               = "flask-alb"
    subnets            = aws_subnet.public[*].id
    load_balancer_type = "application"
    security_groups    = [aws_security_group.alb_sg.id]
}

resource "aws_lb_target_group" "flask_tg_group" {
    name        = "${var.project_name}-alb-tg"
    port        = 5000
    protocol    = "HTTP"
    vpc_id      = aws_vpc.flask_vpc.id
    target_type = "instance"

    health_check {
        healthy_threshold   = "3"
        interval            = "15"
        protocol            = "HTTP"
        matcher             = "200-299"
        timeout             = "10"
        path                = "/healthcheck"
        unhealthy_threshold = "2"
    }
}

resource "aws_lb_listener" "https_forward" {
    load_balancer_arn  = aws_lb.flask_alb.arn
    port               = 80
    protocol           = "HTTP"

    default_action {
        type     = "forward"
        target_group_arn = aws_lb_target_group.flask_tg_group.arn
    }
}resource "aws_sns_topic" "cpu_alert" {
    name = "${var.project_name}-cpu-alert"
}

resource "aws_sns_topic_subscription" "mail_sub" {
    topic_arn = aws_sns_topic.cpu_alert.arn
    protocol  = "email"
    endpoint  = var.my_mail
}

resource "aws_cloudwatch_log_group" "api_logs" {
    name              = "api-logs"
    retention_in_days = 7
}

resource "aws_cloudwatch_metric_alarm" "high_cpu" {
    alarm_name          = "high-cpu-utilization"
    comparison_operator = "GreaterThanOrEqualToThreshold"
    evaluation_periods  = "2"
    metric_name         = "CPUUtilization"
    namespace           = "AWS/EC2"
    period              = "300"
    statistic           = "Average"
    threshold           = "70"

    dimensions = {
      AutoScalingGroupName = aws_autoscaling_group.flask_asg.name
    }

    alarm_actions = [aws_sns_topic.cpu_alert.arn]
    ok_actions    = [aws_sns_topic.cpu_alert.arn]
}resource "aws_ecr_repository" "flask_app" {
    name                 = var.project_name
    image_tag_mutability = "MUTABLE"
    force_delete         = true

    image_scanning_configuration {
        scan_on_push = true
    }
}

resource "aws_ecr_lifecycle_policy" "image_cleanup" {
    repository = aws_ecr_repository.flask_app.name

    policy     = jsonencode({
        rules = [{
            rulePriority = 1
            description = "Keep Only Last 5 Images"
            selection = {
                tagStatus   = "any"
                countType   = "imageCountMoreThan"
                countNumber = 5
            }
            action = {
                type = "expire"
            }
        }]
    })
}resource "aws_iam_role" "api_role" {
    name = "${var.project_name}-api-role"

    assume_role_policy = jsonencode({
        Version       = "2012-10-17"
        Statement    = [{
            Action    = "sts:AssumeRole"
            Effect    = "Allow"
            Principal = { Service = "ec2.amazonaws.com" }
        }] 
    })
}

resource "aws_iam_role_policy_attachment" "ssm_policy" {
    role       = aws_iam_role.api_role.name
    policy_arn = "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
}

resource "aws_iam_role_policy_attachment" "ecr_policy" {
    role       = aws_iam_role.api_role.name
    policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
}

resource "aws_iam_role_policy_attachment" "cw_policy" {
    role       = aws_iam_role.api_role.name
    policy_arn = "arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy"
}

resource "aws_iam_role_policy" "api_custom_policy" {
    name = "${var.project_name}-custom-permissions"
    role = aws_iam_role.api_role.id

    policy = jsonencode({
        Version    = "2012-10-17"
        Statement = [
            {
                Effect   = "Allow"
                Action   = ["secretsmanager:GetSecretValue"]
                Resource = [aws_secretsmanager_secret.db_secret_pass.arn]
            },
            {
                Effect   = "Allow"
                Action   = ["s3:PutObject", "s3:GetObject", "s3:ListBucket"]
                Resource = [
                    aws_s3_bucket.flask_bucket.arn,
                    "${aws_s3_bucket.flask_bucket.arn}/*"
                ]
            }
        ]
    })
}

resource "aws_iam_role" "lambda_role" {
    name = "${var.project_name}-lambda-role"

    assume_role_policy = jsonencode({
        Version       = "2012-10-17"
        Statement    = [{
            Action    = "sts:AssumeRole"
            Effect    = "Allow"
            Principal = { Service = "lambda.amazonaws.com" } 
        }] 
    })
}

resource "aws_iam_role_policy_attachment" "lambda_logs" {
    role       = aws_iam_role.lambda_role.name
    policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

resource "aws_iam_role_policy" "lambda_custom_policy" {
    name = "${var.project_name}-lambda-custom"
    role = aws_iam_role.lambda_role.id

    policy = jsonencode({
        Version  = "2012-10-17"
        Statement = [
          {
            Effect   = "Allow"
            Action   = ["s3:GetObject", "s3:PutObject"]
            Resource = ["${aws_s3_bucket.flask_bucket.arn}/*"]
          }
        ]
    })    
}
data "archive_file" "lamba_zip" {
    type        = "zip"
    source_file = "lambda_function.py"
    output_path = "lambda_function.zip"
}

resource "aws_lambda_function" "slack_notifier" {
    filename = "lambda_function.zip"
    function_name    = "${var.project_name}-slack-notifier"
    role             = aws_iam_role.lambda_role.arn
    handler          = "lambda_function.lambda_handler"
    runtime          = var.python_version
    source_code_hash = data.archive_file.lamba_zip.output_base64sha256

    environment {
      variables = {
        SLACK_WEBHOOK_URL = var.SLACK_WEBHOOK_URL
      }
    }
}

resource "aws_lambda_permission" "allow_cloudwatch" {
    statement_id  = "AllowExecutionFromCloudWatch"
    action        = "lambda:InvokeFunction"
    function_name = aws_lambda_function.slack_notifier.function_name
    principal     = "logs.amazonaws.com"
    source_arn    = "${aws_cloudwatch_log_group.api_logs.arn}:*"
}

resource "aws_cloudwatch_log_subscription_filter" "slack_filter" {
    name            = "slack-error-filter"
    log_group_name  = aws_cloudwatch_log_group.api_logs.name
    filter_pattern  = "?ERROR ?Error ?error"
    destination_arn = aws_lambda_function.slack_notifier.arn
}output "alb_dns" {
    value       = aws_lb.flask_alb.dns_name
    description = "web url"
}

output "rds_endpoint" {
    value       = aws_db_instance.flask_rds.endpoint
    description = "address of rds"
}

output "ecr_url" {
    value       = aws_ecr_repository.flask_app.repository_url
    description = "url for ecr image"
}terraform {
    required_providers {
      aws = {
        source  = "hashicorp/aws"
        version = "~> 5.0"
      }
    }

    required_version = "~> 1.14.0"
}

provider "aws" {
    region = var.default_region

    default_tags {
        tags = {
            Environment = var.environment 
            Project     = var.project_name
            ManagedBy   = "Terraform"
        }
    }
}
resource "aws_db_subnet_group" "flask_db_sg" {
    name       = "db-subnet"
    subnet_ids = aws_subnet.private[*].id
}

resource "aws_db_instance" "flask_rds" {
    identifier             = "flask-db"
    allocated_storage      = 20
    storage_type           = "gp3"
    engine                 = "postgres"
    instance_class         = "db.t3.micro"
    db_name                = "flask_db"
    username               = var.db_username
    password               = random_password.db-pass.result
    skip_final_snapshot    = true
    db_subnet_group_name   = aws_db_subnet_group.flask_db_sg.name
    vpc_security_group_ids = [aws_security_group.rds_sg.id]
    publicly_accessible    = false
}resource "random_id" "s3_bucket_id" {
    byte_length = 4
}

resource "aws_s3_bucket" "flask_bucket" {
    bucket              = "s3-bucket-${random_id.s3_bucket_id.hex}"
    force_destroy       = true
    #object_lock_enable = true
}

resource "aws_s3_bucket_ownership_controls" "flask_bucket_ownership" {
    bucket = aws_s3_bucket.flask_bucket.id
    rule {
        object_ownership = "BucketOwnerPreferred"
    }
}

resource "aws_s3_bucket_public_access_block" "flask_bucket_access" {
    bucket = aws_s3_bucket.flask_bucket.id

    block_public_acls       = true
    block_public_policy     = true
    ignore_public_acls      = true
    restrict_public_buckets = true
}

resource "aws_s3_bucket_acl" "flask_bucket_acl" {
    depends_on = [aws_s3_bucket_ownership_controls.flask_bucket_ownership]
    bucket     = aws_s3_bucket.flask_bucket.id
    acl        = "private"
}

resource "aws_s3_bucket_versioning" "bucket_versioning" {
    bucket = aws_s3_bucket.flask_bucket.id
    versioning_configuration {
      status = "Enabled"
    }
}

resource "aws_s3_object" "uploads_folder" {
    depends_on = [aws_s3_bucket_versioning.bucket_versioning]

    bucket        = aws_s3_bucket.flask_bucket.id
    key           = "uploads/"
    content_type  = "application/x-directory"
    force_destroy = true
}

resource "aws_s3_object" "logs_folder" {
    depends_on = [aws_s3_bucket_versioning.bucket_versioning]

    bucket        = aws_s3_bucket.flask_bucket.id
    key           = "logs/"
    content_type  = "application/x-directory"
    force_destroy = true
}
terraform {
    backend "s3" {
        profile  = "default"
        bucket   = "r-kx-terraform-storage-123"
        key      = "dev.terraform.tfstate"
        encrypt  = true
        region   = "eu-central-1"
        #dynamodb_table = "flask_db_lock" 
    }
}
data "aws_caller_identity" "current" {}resource "random_password" "db-pass" {
    length  = 14
    special = true
    override_special = "_!%^"
}

resource "aws_secretsmanager_secret" "db_secret_pass" {
    name                    = "db-pass-${random_id.s3_bucket_id.hex}"
    recovery_window_in_days = 0
}

resource "aws_secretsmanager_secret_version" "db_pass_ver" {
    secret_id     = aws_secretsmanager_secret.db_secret_pass.id
    secret_string = random_password.db-pass.result
}resource "aws_security_group" "alb_sg" {
    name        = "alb_sg"
    description = "access to ALB"
    vpc_id      = aws_vpc.flask_vpc.id

    ingress {
        protocol    = "tcp"
        from_port   = 80
        to_port     = 80
        cidr_blocks = ["0.0.0.0/0"]
    }

    egress {
        protocol    = "-1"
        from_port   = 0
        to_port     = 0
        cidr_blocks = ["0.0.0.0/0"]
    }
}

resource "aws_security_group" "ec2_sg" {
    name        = "ec2_sg"
    description = "allow inbound access from ALB"
    vpc_id      = aws_vpc.flask_vpc.id

    ingress {
        protocol  = "tcp"
        from_port = 5000
        to_port   = 5000
        security_groups = [aws_security_group.alb_sg.id]
    }

    egress {
        protocol    = "-1"
        from_port   = 0
        to_port     = 0
        cidr_blocks = ["0.0.0.0/0"]
    }
}

resource "aws_security_group" "rds_sg" {
    name        = "rds_sg"
    description = "allow inbound access from ec2 only"
    vpc_id      = aws_vpc.flask_vpc.id

    ingress {
      protocol        = "tcp"
      from_port       = 5432
      to_port         = 5432
      security_groups = [aws_security_group.ec2_sg.id]
    }

    egress {
        protocol    = "-1"
        from_port   = 0
        to_port     = 0
        cidr_blocks = ["0.0.0.0/0"]
    }
}

resource "aws_network_acl" "main_nacl" {
    vpc_id     = aws_vpc.flask_vpc.id
    subnet_ids = aws_subnet.private[*].id

    ingress {
        protocol   = "tcp"
        rule_no    = 100
        action     = "deny"
        cidr_block = "0.0.0.0/0"
        from_port  = 23
        to_port    = 23
    }

    ingress {
        protocol   = "tcp"
        rule_no    = 110
        action     = "allow"
        cidr_block = "0.0.0.0/0"
        from_port  = 80
        to_port    = 80
    }

    ingress {
        protocol   = "tcp"
        rule_no    = 120
        action     = "allow"
        cidr_block = "0.0.0.0/0"
        from_port  = 443
        to_port    = 443
    }

    ingress {
        protocol   = "tcp"
        rule_no    = 130
        action     = "allow"
        cidr_block = "0.0.0.0/0"
        from_port  = 1024
        to_port    = 65535
    }

    ingress {
        protocol   = "tcp"
        rule_no    = 140
        action     = "allow"
        cidr_block = "0.0.0.0/0"
        from_port  = 5000
        to_port    = 5000
    }

    ingress {
        protocol   = "tcp"
        rule_no    = 150
        action     = "allow"
        cidr_block = "0.0.0.0/0"
        from_port  = 5432
        to_port    = 5432
    }

    egress {
        protocol   = "tcp"
        rule_no    = 160
        action     = "allow"
        cidr_block = "0.0.0.0/0"
        from_port  = 5000
        to_port    = 5000
    }

    egress {
        protocol   = "tcp"
        rule_no    = 170
        action     = "allow"
        cidr_block = "0.0.0.0/0"
        from_port  = 5432
        to_port    = 5432

    }

    egress {
        protocol   = "tcp"
        rule_no    = 180
        action     = "allow"
        cidr_block = "0.0.0.0/0"
        from_port  = 1024
        to_port    = 65535
    }

    egress {
        protocol   = "tcp"
        rule_no    = 190
        action     = "allow"
        cidr_block = "0.0.0.0/0"
        from_port  = 80
        to_port    = 80
    }

    egress {
        protocol   = "tcp"
        rule_no    = 200
        action     = "allow"
        cidr_block = "0.0.0.0/0"
        from_port  = 443
        to_port    = 443
    }
}

resource "aws_wafv2_web_acl" "flask_waf" {
    count       = var.enable_waf ? 1 : 0
    name        = "flask_waf"
    description = "aws managed rules for flask app"
    scope       = "REGIONAL"

    default_action {
        allow {}
    }

    rule {
        name     = "AWS-AWSManagedRulesCommonRuleSet"
        priority = 1

        override_action {
            none {}
        }

        statement {
            managed_rule_group_statement {
                name        = "AWSManagedRulesCommonRuleSet"
                vendor_name = "AWS"
            }
        }

        visibility_config {
            cloudwatch_metrics_enabled = true
            metric_name                = "aws-common-rules"
            sampled_requests_enabled   = true
        }
    }

    rule {
        name     = "AWS-AWSManagedRulesAmazonIpReputationList"
        priority = 2

        override_action {
            none {}
        }

        statement {
            managed_rule_group_statement {
                name        = "AWSManagedRulesAmazonIpReputationList"
                vendor_name = "AWS"
            }
        }

        visibility_config {
            cloudwatch_metrics_enabled = true
            metric_name                = "aws-ip-reputation"
            sampled_requests_enabled    = true
        }
    }

    visibility_config {
        cloudwatch_metrics_enabled = true
        metric_name                = "flask-waf-main"
        sampled_requests_enabled   = true 
    }
}

resource "aws_wafv2_web_acl_association" "waf_alb_asso" {
    count        = var.enable_waf ? 1 : 0
    resource_arn = aws_lb.flask_alb.arn
    web_acl_arn  = aws_wafv2_web_acl.flask_waf[0].arn
}

resource "aws_security_group" "secrets_sg" {
    name        = "secrets-endpoint-sg"
    description = "Allow HTTPS Inbound from VPC"
    vpc_id      = aws_vpc.flask_vpc.id

    ingress {
        protocol    = "tcp"
        from_port   = 443
        to_port     = 443
        cidr_blocks = [aws_vpc.flask_vpc.cidr_block]
    }

    egress {
        protocol    = "-1"
        from_port   = 0
        to_port     = 0
        cidr_blocks = ["0.0.0.0/0"]
    }
}resource "aws_iam_instance_profile" "api_instance_profile" {
    name = "${var.project_name}-instance-profile"
    role = aws_iam_role.api_role.name
}

data "aws_ami" "ubuntu" {
    most_recent = true
    owners      = ["099720109477"]

    filter {
        name   = "name"
        values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]
    }

    filter {
        name   = "virtualization-type"
        values = ["hvm"]
    }
}

resource "aws_key_pair" "aws_auth" {
    key_name   = var.key_name
    public_key = file(var.pub_key_path) 
}

resource "aws_launch_template" "flask_api_lt" {
    name_prefix   = "${var.project_name}-flask-lt"
    image_id      = data.aws_ami.ubuntu.id
    instance_type = var.instance_type
    key_name      = aws_key_pair.aws_auth.key_name

    iam_instance_profile {
      name = aws_iam_instance_profile.api_instance_profile.id
    }

    vpc_security_group_ids = [aws_security_group.ec2_sg.id]

    user_data = base64encode(<<-EOF
#!/bin/bash
apt-get update
apt-get install -y python3-pip
echo "Server is ready for Ansible"
EOF
)
}

resource "aws_autoscaling_group" "flask_asg" {
    name              = "${var.project_name}-flask-asg"
    desired_capacity  = 2
    max_size          = 4
    min_size          = 1
    target_group_arns = [aws_lb_target_group.flask_tg_group.arn]
    vpc_zone_identifier = aws_subnet.private[*].id

    launch_template {
        id      = aws_launch_template.flask_api_lt.id
        version = "$Latest"
    }
}
variable "instance_type" {}

variable "key_name" {}

variable "pub_key_path" {}

variable "azs" {}

variable "vpc_cidr" {}

variable "default_region" {}

variable "environment" {}

variable "project_name" {}

variable "enable_waf" {}

variable "db_username" {}

variable "my_mail" {}

variable "SLACK_WEBHOOK_URL" {}

variable "python_version" {}

 data "aws_availability_zones" "available_zones" {
    state = "available"
}

resource "aws_vpc" "flask_vpc" {
    cidr_block           = var.vpc_cidr
    instance_tenancy     = "default"
    enable_dns_support   = true
    enable_dns_hostnames = true 
}

resource "aws_subnet" "public" {
    count                   = var.azs
    vpc_id                  = aws_vpc.flask_vpc.id
    cidr_block              = cidrsubnet(aws_vpc.flask_vpc.cidr_block, 8, count.index + 1)
    availability_zone       = data.aws_availability_zones.available_zones.names[count.index]
    map_public_ip_on_launch = true
}

resource "aws_subnet" "private" {
    count             = var.azs
    vpc_id            = aws_vpc.flask_vpc.id
    cidr_block        = cidrsubnet(aws_vpc.flask_vpc.cidr_block, 8, count.index + 11)
    availability_zone = data.aws_availability_zones.available_zones.names[count.index]
}

resource "aws_internet_gateway" "igw" {
    vpc_id = aws_vpc.flask_vpc.id
}

resource "aws_eip" "nat_eip" {
    domain     = "vpc"
    depends_on = [aws_internet_gateway.igw]
}

resource "aws_nat_gateway" "nat" {
    connectivity_type = "public"
    allocation_id     = aws_eip.nat_eip.id
    subnet_id         = aws_subnet.public[0].id
}

resource "aws_route_table" "public_rt" {
    vpc_id = aws_vpc.flask_vpc.id
}

resource "aws_route" "public_r" {
    route_table_id         = aws_route_table.public_rt.id
    destination_cidr_block = "0.0.0.0/0"
    gateway_id             = aws_internet_gateway.igw.id
}

resource "aws_route_table_association" "public_rt_asso" {
    count          = var.azs
    subnet_id      = aws_subnet.public[count.index].id
    route_table_id = aws_route_table.public_rt.id
}

resource "aws_route_table" "private_rt" {
    vpc_id = aws_vpc.flask_vpc.id
}

resource "aws_route" "private_r" {
    route_table_id         = aws_route_table.private_rt.id
    destination_cidr_block = "0.0.0.0/0"
    nat_gateway_id         = aws_nat_gateway.nat.id
}

resource "aws_route_table_association" "private_rt_asso" {
    count          = var.azs
    subnet_id      = aws_subnet.private[count.index].id
    route_table_id = aws_route_table.private_rt.id
}

resource "aws_vpc_endpoint" "s3" {
    vpc_id            = aws_vpc.flask_vpc.id
    service_name      = "com.amazonaws.${var.default_region}.s3"
    vpc_endpoint_type = "Gateway"
}

resource "aws_vpc_endpoint_route_table_association" "s3_public" {
    route_table_id  = aws_route_table.public_rt.id
    vpc_endpoint_id = aws_vpc_endpoint.s3.id
}

resource "aws_vpc_endpoint_route_table_association" "s3_private" {
    route_table_id  = aws_route_table.private_rt.id
    vpc_endpoint_id = aws_vpc_endpoint.s3.id
}

resource "aws_vpc_endpoint" "secrets_manager" {
    vpc_id              = aws_vpc.flask_vpc.id
    service_name        = "com.amazonaws.${var.default_region}.secretsmanager"
    vpc_endpoint_type   = "Interface"
    subnet_ids          = aws_subnet.private[*].id
    private_dns_enabled = true
    security_group_ids  = [aws_security_group.secrets_sg.id]
}